# Plain rules

Plain rules allow a full customization of a rule with specific needs by means of setting the final EPL statement used by the Esper engine inside perseo-core. In order to work with perseo (front-end) properly, the EPL statement must fulfill several conventions for the rule to be able to operate on the incoming events and trigger adequate actions.

The “anatomy” of a rule is as follows

```json
{
   "name":"blood_rule_update",
   "text":"select *,\"blood_rule_update\" as ruleName, *, ev.BloodPressure? as Pression, ev.id? as Meter from pattern [every ev=iotEvent(cast(cast(BloodPressure?,String),float)>1.5 and type=\"BloodMeter\")]",
   "action":{
      "type":"update",
      "parameters":{
         "name":"abnormal",
         "value":"true",
         "type":"boolean"
      }
   }
}
```
The fields (all must be present) are

* **name**: name of the rule, used as identifier
* **text**: EPL statment for the rule engine in perseo-core
* **action**: action to be performed by perseo if the rule is fired from the core

The rule name must consist of the ASCII characters from A to Z, from a to z, digits (0-9), underscore (_) and dash (-). It can have a maximum length of 50 characters.

## EPL text
The field ```text``` of the rule must be a valid EPL statement and additionally must honor several restrictions to match expectations of perseo and perseo-core.

EPL is documented in [Esper web] (http://www.espertech.com/esper/documentation.php)

A EPL statement to use with perseo could be:

```
select *, "blood_rule_update" as ruleName,
	 ev.BloodPressure? as Pression, ev.id? as Meter
from pattern
 [every ev=iotEvent(cast(cast(BloodPressure?,String),float)>1.5 and type="BloodMeter")]
```


* The rule name must be present with **ruleName** alias. It must be equal to the ‘name’ field of the rule object
* The *from* pattern must name the event as **ev** and the event stream from which take events must be **iotEvent**
* A *type=* condition must be concatenated for avoiding mixing different kinds of entities

The used entity's attributes must be cast to `float` in case of being numeric (like  in the example). Alphanumeric 
values must be cast to `String`. Nested cast to string and to float is something we are analyzing, and could be 
unnecessary in a future version. Use it by now. All the attributes in the notification from Orion are available in the 
event object, **ev**,  like *ev.BlodPressure?* and *ev.id?*. A question mark is *necessary* for EPL referring ‘dynamic’ 
values.


<a name="actions"></a>
## Actions

When a rule is fired, the "complex event" generated by the select clause is sent to perseo (front-end) which executes the action using the generated event as parameter to the action.

There are a predefined set of actions: sending a SMS,  sending  a email, updating an attribute of the entity that fired the rule and making a HTTP POST to a provided URL.



The action must be provided in the ```action``` field of rule. An example:
```json
   "action":{
      "type":"update",
      "parameters":{
         "name":"abnormal",
         "value":"true",
         "type":"boolean"
      },
      "interval" : "30e3"
   }

```

The `type` field is mandatory and must be one of
* `update`: update an entity's attribute
* `sms`: send a SMS
* `email`: send an email
* `post`: make an HTTP POST
* `twitter`: send a twitter

An action can *optionally* have a field `interval` for limiting the frequency of the action execution (for the rule and
entity which fired it). The value is expressed in milliseconds and is the minimum period between executions. Once the action 
is executed _successfully_, it won't be executed again until that period has elapsed. All the request from core to execute
it are silently discarded. This way, the rate of executions for an entity and rule can be limited. (Strictly, the minimum
time between executions)

### String substitution syntax

Some of the fields of an `action` (see detailed list below) can include a reference to one of the fields of the notification/event. This allows include information as the pression value received, the id of the device, etc. For example, the actions `sms`, `email`, `post` include a field `template` used to build the body of message/request. This text can include placeholders for attributes of the generated event. That placeholder has the form `${X}`, where `X` may be:

* `id` for the id of the entity that triggers the rule.
* `type` for the type of the entity that triggers the rule
* Any other value is interpreted as the name of an attribute in the entity which triggers the rule and the placeholder is substituded by the value of that attribute.

All alias for simple event attributes or "complex" calculated values can be directly used in the placeholder with their name. And any of the original event attributes (with the special cases for `id` and `type` meaning entity ID and type, respectively) can be referred too.

This substitution can be used in the the following fields:
* `template`, `from`, `to` and `subject` for `email` action
* `template` for `post` action
* `template` for `sms` action
* `template` for `twitter` action
* `id`, `type`, `name`, `value`, `ìsPattern` for `update` action


### SMS action

Sends a SMS to a number set as an action paramter with the body of the message built from the template
```json
 "action": {
        "type": "sms",
        "template": "Meter ${Meter} has pression ${Pression}.",
        "parameters": {
            "to": "123456789"
        }
    }
```
The field `parameters` include a field `to` with the number to send the message to.

The `template` and `to` fields perform [attribute substitution](#string-substitution-syntax).

### email action

Sends an email to the recipient set in the action parameters, with the body mail build from the `template` field. A field `to` in `parameters` sets the recipient and a field `from`sets the sender's email address. Also the subject of the email can be set in the field `subject` in `parameters`.

```json
 "action": {
        "type": "email",
        "template": "Meter ${Meter} has pression ${Pression} (GEN RULE)",
        "parameters": {
            "to": "someone@telefonica.com",
            "from": "cep@system.org",
            "subject": "It's The End Of The World As We Know It (And I Feel Fine)"
        }
    }
```

The `template`, `from`, `to` and `subject` fields perform [string substitution](#string-substitution-syntax).

### update attribute action
Updates an specified attribute of a given entity (in the Context Broker instance specified in the Perseo configuration). The `parameters` map includes the following fields:

* **name**: *mandatory*, attribute name to set
* **value**: *mandatory*, attribute value to set
* id: optional, the id of the entity which attribute is to be updated (by default the id of the entity that triggers the rule is used, i.e. `${id}`)
* type: optional, the type of the entity which attribute is to be updated (by default the type of the entity that triggers the rule is usedi.e. `${type}`)
* isPattern: optional, `false` by default
* attrType: optional, type of the attribute to set. By default, not set (in which case, only the attribute value is changed).
* trust: optional, trust token for getting an access token from Auth Server which can be used to get to a Context Broker behind a PEP.


```json
"action":{
        "type":"update",
        "parameters":{
            "id":"${id}_mirror",
            "name":"abnormal",
            "attrType":"boolean",
            "value":"true"
        }
    }
```
The `name` parameter cannot take `id` or `type` as a value, as that would refer to the entity's id and the entity's type (which are not updatable) and not to an attribute with any of those names. Trying to create such action will return an error.

The `id`, `type`, `name`, `value`, `ìsPattern` fields perform [string substitution](#string-substitution-syntax).

First time an update action using trust token is triggered, Perseo interacts with Keystone to get the temporal auth token corresponding to that trust token. This auth token is cached and used in every new update associated to the same action. Eventually, Perseo can receive a 401 Not Authorized due to auth token expiration. In that case, Perseo interacts again with Keystone to get a fresh auth token, then retries the update that causes the 401 (and the cache is refreshed with the new auth token for next updates).

It could happen (in theory) that a just got auth token also produce a 401 Not authorized, however this would be an abnormal situation: Perseo logs the problem with the update but doesn't try to get a new one from Keystone. Next time Perseo triggers the action, the process may repeat, i.e. first update attemp fails with 401, Perseo requests a fresh auth token to Keystone, the second update attemp fails with 401, Perseo logs the problem and doesn't retry again.


### HTTP POST action
Makes an HTTP POST to an URL specified in `url` inside `parameters`, sending a body built from `template`.

```json
 "action": {
        "type": "post",
        "template": "Meter ${Meter} has pression ${Pression}.",
        "parameters": {
            "url": "localhost:1111"
        }
    }
```

Note that you can encode a JSON in the `template` field:

```json
 "action": {
        "type": "post",
        "template": "{\"meter\":\"${Meter}\", \"pression\": ${Pression}}",
        "parameters": {
            "url": "localhost:1111"
        }
    }
```

The `template` and `url` fields perform [string substitution](#string-substitution-syntax).

### twitter action

Updates the status of a twitter account, with the text build from the `template` field. The field `parameters` must contain the values for the consumer key and secret and the access token key and access token secret of the pre-provisioned application associated to the twitter user.

```json
 "action": {
        "type": "twitter",
        "template": "Meter ${Meter} has pression ${Pression} (GEN RULE)",
        "parameters": {
          "consumer_key": "xvz1evFS4wEEPTGEFPHBog",
          "consumer_secret": "L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg",
          "access_token_key": "xvz1evFS4wEEPTGEFPHBog",
          "access_token_secret": "L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg"
        }
    }
```

The `template` field performs [string substitution](#string-substitution-syntax).

## Metadata and object values

Metadata values can be accessed by adding the suffix `__metadata__x` to the attribute name, being `x` the name of the 
metadata attribute. This name can be used in the EPL text of the rule and in the parameters of the action which accept 
string substitution. If the value of the metadata item is an object itself, nested fields can be referred by additional 
suffixes beginning with double underscore and the hierarchy can be walked down by adding more suffixes, like
 `__metadata__x__subf1__subf12`.

For example:
The metadata in an event/notice like

```
{
  "subscriptionId" : "51c04a21d714fb3b37d7d5a7",
  "originator" : "localhost",
  "contextResponses" : [
    {
      "contextElement" : {
        "attributes" : [
          {
            "name" : "BloodPressure",
            "type" : "centigrade",
            "value" : "2",
            "metadata": {
              "crs": {
                "value": {"system": "WGS84"}
              }
            }
          },
		{
            "name" : "TimeInstant",
            "type" : "urn:x-ogc:def:trs:IDAS:1.0:ISO8601",
            "value" : "2014-04-29T13:18:05Z"
          }
        ],
        "type" : "BloodMeter",
        "isPattern" : "false",
        "id" : "bloodm1"
      },
      "statusCode" : {
        "code" : "200",
        "reasonPhrase" : "OK"
      }
    }
  ]
}
```

could be used by a rule so

```json
{
    "name": "blood_rule_email_md",
    "text": "select *,\"blood_rule_email_md\" as ruleName, *,ev.BloodPressure? as Pression, ev.id? as Meter from pattern [every ev=iotEvent(cast(BloodPressure__metadata__crs__system?,String)=\"WGS84\" and type=\"BloodMeter\")]",
    "action": {
        "type": "email",
        "template": "Meter ${Meter} has pression ${Pression} (GEN RULE) and system is ${BloodPressure__metadata__crs__system}",
        "parameters": {
            "to": "someone@org.com",
            "from": "perseo_cep@telefonica.com",
            "subject": "MD VALUE: ${BloodPressure__metadata__crs__system}"
        }
    }
}
```

Generally, fields of attribute values which are objects themselves are accessible by adding to the name of the field a 
double underscore prefix, so an attribute `x` with fields `a`, `b`, `c`, will allow these fields to be referred as 
`x__a`, `x__b` and `x__c`.
