# Plain rules

Plain rules allow a full customization of a rule with specific needs by means of setting the final EPL statement used by the Esper engine inside perseo-core. In order to work with perseo (front-end) properly, the EPL statement must fulfill several conventions for the rule to be able to operate on the incoming events and trigger adequate actions.

The “anatomy” of a rule is as follows

```json
{
   "name":"blood_rule_update",
   "text":"select *,\"blood_rule_update\" as ruleName, *, ev.BloodPressure? as Pression, ev.id? as Meter from pattern [every ev=iotEvent(cast(cast(BloodPressure?,String),float)>1.5 and type=\"BloodMeter\")]",
   "action":{
      "type":"update",
      "parameters":{
         "name":"abnormal",
         "value":"true",
         "type":"boolean"
      }
   }
}
```
The fields (all must be present) are

* **name**: name of the rule, used as identifier
* **text**: EPL statment for the rule engine in perseo-core
* **action**: action to be performed by perseo if the rule is fired from the core

The rule name must consist of the ASCII characters from A to Z, from a to z, digits (0-9), underscore (_) and dash (-). It can have a maximum length of 50 characters.

## EPL text
The field ```text``` of the rule must be a valid EPL statement and additionally must honor several restrictions to match expectations of perseo and perseo-core.

EPL is documented in [Esper web] (http://esper.codehaus.org/esper-4.7.0/doc/reference/en-US/html_single/index.html#epl_clauses)

A EPL statement to use with perseo could be:

```
select *, "blood_rule_update" as ruleName,
	 ev.BloodPressure? as Pression, ev.id? as Meter
from pattern
 [every ev=iotEvent(cast(cast(BloodPressure?,String),float)>1.5 and type="BloodMeter")]
```


* The rule name must be present with **ruleName** alias. It must be equal to the ‘name’ field of the rule object
* The *from* pattern must name the event as **ev** and the event stream from which take events must be **iotEvent**
* A *type=* condition must be concatenated for avoiding mixing different kinds of entities

The used entity's atrributes must be cast to `float` in case of being numeric (like  in the example). Alphanumeric values must be cast to `String`. Nested cast to string and to float is something we are analyzing, and could be unnecessary in a future version. Use it by now. All the attributes in the notification from Orion are available in the event object, **ev**,  like *ev.BlodPressure?* and *ev.id?*. A question mark is *necessary* for EPL referring ‘dynamic’ values.

<a name="actions"></a>
## Actions

When a rule is fired, the "complex event" generated by the select clause is sent to perseo (front-end) which executes the action using the generated event as parameter to the action.

There are a predefined set of actions: sending a SMS,  sending  a email, updating an attribute of the entity that fired the rule and making a HTTP POST to a provided URL.



The action must be provided in the ```action``` field of rule. An example:
```json
   "action":{
      "type":"update",
      "parameters":{
         "name":"abnormal",
         "value":"true",
         "type":"boolean"
      }
   }

```

The `type` field is mandatory and must be one of
* `update`: update an entity's attribute
* `sms`: send a SMS
* `email`: send an email
* `post`: make an HTTP POST
* `twitter`: send a twitter

The actions `sms`, `email`, `post` include a field `template` used to build the body of message/request. This text can include placeholders for attributes of the generated event. That placeholder has the form `${` *attribute* `}` which will be substituted by the value of the event's attribute.  The name of the attribute must be prefixed with "ev__" if no alias in the `select` clause is provided. All alias for simple event attributes or "complex" calculated values can be directly used in the placeholder with their name. Any of the original event attributes can be referred as **ev__** *name* (double underscore), if an alias hasn't been given to them.

### SMS action

Sends a SMS to a number set as an action paramter with the body of the message built from the template
```json
 "action": {
        "type": "sms",
        "template": "Meter ${Meter} has pression ${Pression}.",
        "parameters": {
            "to": "123456789"
        }
    }
```
The field `parameters` include a field `to` with the number to send the message to.

### email action

Sends an email to the recipient set in the action parameters, with the body mail build from the `template` field. A field `to` in `parameters` sets the recipient and a field `from`sets the sender's email address. Also the subject of the email can be set in the field `subject` in `parameters`. 

```json
 "action": {
        "type": "email",
        "template": "Meter ${Meter} has pression ${Pression} (GEN RULE)",
        "parameters": {
            "to": "someone@telefonica.com",
            "from": "cep@system.org"
            "subject": "It's The End Of The World As We Know It (And I Feel Fine)"
        }
    }
```

### update attribute action
Updates an specified attribute of a given entity (in the Context Broker instance specified in the Perseo configuration). The `parameters` map includes the following fields:

* **name**: *mandatory*, attribute name to set
* **value**: *mandatory*, attribute value to set
* id: optional, the id of the entity which attribute is to be updated (by default the id of the entity that triggers the rule is used, i.e. `${id}`)
* type: optional, the type of the entity which attribute is to be updated (by default the type of the entity that triggers the rule is usedi.e. `${type}`)
* isPattern: optional, `false` by default
* attrType: optional, type of the attribute to set. By default, not set (in which case, only the attribute value is changed).
* trust: optional, trust token for getting an access token from Auth Server which can be used to get to a Context Broker behind a PEP.

The values of these fields can be either literal values or use `${X}` substitution macros (except trust), where `X` may be:

* `id` for the id of the entity that triggers the rule. As example, if we want the entity with "id" `sensor1` to update the entity with "id" `sensor1_friend` we should set the `id` field in `parameters` with the value `"${id}_friend"`
* `type` for the type of the entity that triggers the rule
* Any other value is interpreted as the name of an attribute in the entity which triggers the rule and the macro is substituded by the value of that attribute.

```json
"action":{
        "type":"update",
        "parameters":{
            "id":"${id}_mirror",
            "name":"abnormal",
            "attrType":"boolean",
            "value":"true"
        }
    }
```
The `name` parameter cannot take `id` or `type` as a value. Those values always refer to the entity's id and the entity's type and not to an attribute with any of those names. Trying to create such action will return an error.

First time an update action using trust token is triggered, Perseo interacts with Keystone to get the temporal auth token corresponding to that trust token. This auth token is cached and used in every new update associated to the same action. Eventually, Perseo can receive a 401 Not Authorized due to auth token expiration. In that case, Perseo interacts again with Keystone to get a fresh auth token, then retries the update that causes the 401 (and the cache is refreshed with the new auth token for next updates).

It could happen (in theory) that a just got auth token also produce a 401 Not authorized, however this would be an abnormal situation: Perseo logs the problem with the update but doesn't try to get a new one from Keystone. Next time Perseo triggers the action, the process may repeat, i.e. first update attemp fails with 401, Perseo requests a fresh auth token to Keystone, the second update attemp fails with 401, Perseo logs the problem and doesn't retry again.

### HTTP POST action
Makes an HTTP POST to an URL specified in `url` inside `parameters`, sending a body built from `template`.


```json
 "action": {
        "type": "post",
        "template": "Meter ${Meter} has pression ${Pression}.",
        "parameters": {
            "url": "localhost:1111"
        }
    }
```

### twitter action

Updates the status of a twitter account, with the text build from the `template` field. The field `parameters` must contain the values for the consumer key and secret and the access token key and access token secret of the pre-provisioned application associated to the twitter user.

```json
 "action": {
        "type": "twitter",
        "template": "Meter ${Meter} has pression ${Pression} (GEN RULE)",
        "parameters": {
          "consumer_key": "xvz1evFS4wEEPTGEFPHBog",
          "consumer_secret": "L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg",
          "access_token_key": "xvz1evFS4wEEPTGEFPHBog",
          "access_token_secret": "L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg"
        }
    }
```
